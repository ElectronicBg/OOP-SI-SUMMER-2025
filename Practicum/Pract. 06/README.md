# Теория:

**Задача 1:** Какво ще се отпечата?

```c++
class A {
	int a;
public:

	A() {
    		std::cout << "A()" << std::endl;
    		a = 37;
	}

	A(const A& other) {
    		std::cout << "A(const A& other)" << std::endl;
    		a = other.a;
	}

	A& operator=(const A& other) {
    		std::cout << "op=A" << std::endl;
    		if (this != &other) {
        			a = other.a;
    		}
    		return *this;
	}
	~A() {
    		std::cout << "~A()" << std::endl;
	}
};

int main() {
	A a1;
	A a2;
	a1 = a2;
	A a3 = a1;
}
```

**Задача 2:** Какво ще се отпечата? Ползваме класът А от предния пример.

```c++
class B {
	A obj;
public:
	B() {
    		std::cout << "B()" << std::endl;
	}

		B(const B& other): obj(other.obj) {
    		std::cout << "B(const B& other)" << std::endl;
	}

	B& operator=(const B& other) {
    		std::cout << "op=B" << std::endl;
    		if (this != &other) {
        			obj = other.obj;
    		}
    		return *this;
	}

	~B() {
    		std::cout << "~B()" << std::endl;
	}
};

int main() {
	B b1;
	b1 = b1;
	B b2 = b1;
	b1 = b2;
}
```

**Задача 3:** Какво ще се отпечата? 

```c++
class A {
	int a;
public:
	A(int num) : a(num) {
    		std::cout << "A(int)" << std::endl;
	}

	A(const A& other) {
    		std::cout << "A(const A& other)" << std::endl;
    		a = other.a;
	}

	A& operator=(const A& other) {
    		std::cout << "op=A" << std::endl;
    		if (this != &other) {
        			a = other.a;
    		}
    		return *this;
	}
	~A() {
    		std::cout << "~A()" << std::endl;
	}
};

class B {
	char c;
public:
	B(char ch) : c(ch){
    		std::cout << "B(char)" << std::endl;
	}

	B(const B& other): c(other.c) {
    		std::cout << "B(const B& other)" << std::endl;
	}

	B& operator=(const B& other) {
    		std::cout << "op=B" << std::endl;
    		if (this != &other) {
        			c = other.c;
    		}
    		return *this;
	}

	~B() {
    		std::cout << "~B()" << std::endl;
	}
};

class C {
	A a;
	B b;
public:
	C() : b('r'), a(3) {
    		std::cout << "C()" << std::endl;
	}

	C(const C& other) : a(other.a), b(other.b) {
    		std::cout << "C(const C& other)" << std::endl;
	}

	C& operator=(const C& other) {
    		std::cout << "op=C" << std::endl;
    		if (this != &other) {
        			a = other.a;
        			b = other.b;
    		}
    		return *this;
	}

	~C() {
    		std::cout << "~C()" << std::endl;
	}
};

int main() {
	C* ptr = new C();
	C obj;
	obj = *ptr;
}
```


# Задачи:

**Задача 1:** Да се разпише клас Message, който съдържа следните полета: пращач, получател, съобщение (стрингове) 
и големина на шрифта (инт).

**Задача 2:**

Имплементирайте стек от int с променяща се дължина - когато се напълни да се заделя нова памет, 
с двойно по-голям размер, и да се копират старите данни в нея. Операциите с динамичния стек са същите като при статичния:
 - Push(int a) - слага елемента a на върха на стека
 - Pop() - премахва най-горния елемент на стека
 - Peek() - връща най-горния елемент на стека, без да го премахва

//Стек - представете си го като купчина от обекти. Може да добавяте само на върха и да премахвате само от него.

**Задача 3:**

Реализирайте клас Task, който описва една задача за деня. С негова помощ можете да реализирате дневен график.
Една задача се характеризира с:
описание (символен низ, който може да има произволна дължина);
приоритет (цяло положително число, по-голямата стойност означава по-голям приоритет);
статус (булева стойност, дали задачата вече е свършена или не);
продължителност (положително число в минути).
Трябва да вземете предвид следните изисквания:
Описанието на задачата е нещо, което се задава при създаването ѝ и повече не трябва да може да се променя.
Една задача винаги се създава като незавършена. По-късно може да бъде обявена за завършена, 
но не се допуска по-късно отменяне на тази промяна, т.е. веднъж завършена, задачата не може отново да бъде върната в статус незавършена.
За класа Task:
 - дефинирайте подходящи конструктори и нужните методи за осигуряване на коректен жизнен цикъл;
 - дефинирайте метод за запис в текстов поток;
 - дефинирайте конструктор, който създава обект по данни от текстов поток 
(съгласно формата, който сте използвали за запис в предната функция);
 - дефинирайте подходящи методи за достъп до членовете. При промяна, задължително осигурявайте валидни стойности;
 - дефинирайте метод, който сравнява дадена задача с друга по приоритет. За две задачи с еднакъв 
приоритет тази с по-малката продължителност е по-голяма.


**Задача 4:** Реализирайте клас MonthlyPlanner, който описва график със задачи за всеки ден от даден месец. 
В началото графикът е празен, няма съхранени задачи.
Дефинирайте метод, чрез който към даден график се добавя задача. 
Освен задачата, този метод трябва да получава като аргумент за кой ден да бъде тя и в кой час да започне. 
Също така трябва да може да се премахва дадена задача по подаден ден и номер в конкретния ден.
За класа MonthlyPlanner дефинирайте още следните методи:
 - метод, който по подаден ден, извежда на екрана всички незавършени задачи, записани за него.
 - метод, който по зададен ден и час, маркира като изпълнена задачата, която е планирана в този момент.
 - метод за съхранение на данните от един такъв обект в текстов файл, както и метод за прочитане на така записан обект.
Приемаме, че за всеки ден максималния брой задачи може да е 10, а всеки месец име 30 дни.

